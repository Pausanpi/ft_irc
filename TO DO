El destructor mirarlo bien :) -> OK ✅

Try/catch en el main para que los errores sean throw(run time error) -> OK ✅

En el PASS podríamos poner que el mensaje de bienvenido se pongo si o si luego del USER y quizás que si o si se tenga que poner el NICK y el USER después de la contraseña -> OK ✅

Revisar que cuando te logees no puedas ponerte un NICK que ya existe -> OK

Revisar los mensajes de error que todos estén bien

En el MODE hay que hacer el + y el - de los modos -> OK ✅

******************************************************************************

Recomendación de cerrar los clietnes tambien en el destructor -> OK ✅

en el send, chekiar errores -> OK ✅

me insisten mucho ne iniciar los fds a -1 o alguna wea así, no me entero bien. Es para luego para el accept y el handler y el clear -> OK ✅

broadcast puede ser vulnerable a punteros nulos -> OK ✅
Pointer-based sets (Client*)	⚠️	Ensure cleanup from all sets when client disconnects -> OK ✅

en el chanel la flag the invite only debería iniciarse. -> OK ✅

me avisa tambien de lo del buffer y los mensajes completos -> OK ✅

To avoid "dangling" pointers in Channel sets (_members, _operators, _invited), you must make sure to:
→ Remove this client from all channels when removeClient() is called. -> OK ✅
recomienda esto: a saber que es verdad
for (std::map<std::string, Channel>::iterator it = _channels.begin(); it != _channels.end(); ++it) {
    it->second.removeMember(&_clients[index]);
    it->second.removeOperator(&_clients[index]);
    it->second.removeInvited(&_clients[index]);
}
_clients[index].clear();

em el handler se sufiere normalizarlo todo a mayusculas (un upper b'asicamente) -> OK ✅


PARA EL CONTROL D
-Add a std::string _recvBuffer; to Client class.
-When you recv(), append data to Client::_recvBuffer.
-Whenever a full line (\r\n) is found, extract it and call handleInput() on that line.
-Keep any incomplete data in _recvBuffer for next time.
(a;adir limpieza del buffer al disconect)


el diabloso \r\n al final de los mensajes me esta jodiendo la vida
como est'a ahora parece que se queda lal inea sin borrar
se puede poner un modo estricot para hexchat:
bool strictMode = false; // or true if testing with HexChat only
if (strictMode) {
    // Only look for \r\n exactly
} else {
    // Accept \n and strip \r if present
}

declaracion de server dentro de comandhandler
-en el PASS el PASS en el mensaje y el \r
-en el NICK dice que el break esta mal la logica uqe se setea igualmetne aunque se repita.

******************************************************************************


NICK - USER -> OK

PRIVMSG -> OK

JOIN + MODE +i + INVITE -> OK

PRIVMSG canal -> OK

KICK -> OK

INVITE sin ser operador (no deja) -> OK

QUIT -> OK pero mejorable

PASS -> OK

**********************************************************************************

COMANDOS

- PASS contraseña (lo primero que hay que hacer)

- NICK nombre

- USER nombre 0 * :Nombre 
	USER <username> <hostname> <servername> <realname>
	1. <username> Nombre de usuario (sin espacios)
		- Identificador público del usuario
	2. <hostname> Máscara de host (normalmente 0 para clientes)
		- Históricamente usado para identificaciones complejas
		- Hoy casi siempre se usa 0 (ignorado por la mayoría de servidores)
	3. <servername> Nombre del servidor (normalmente * para clientes)
		- Reliquia de redes IRC distribuidas
		- Casi siempre se usa * (wildcard)
	4. <realname> Nombre real (precedido por :)
		- Puede contener espacios
		- Aparece en whois y otros comandos


- PRIVMSG nombre :mensaje

- PRIVMSG #canal nombre :mensaje

- JOIN #canal

- MODE #canal +i (hace el canal privado)

- INVITE nombre #canalprivado

- KICK #canal nombre :razon







-----------------------------------------
HEXchat
RAW LOG
1º persona en unirse a canal:
- join :canal
- 353
- 366
- 324
- 421